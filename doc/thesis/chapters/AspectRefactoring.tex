% !TEX root = ../thesis.tex

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Chapter: Aspect refactoring 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Taming Aspects of JHotDraw with managed data}\label{AspectRefactoring}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Crosscutting Concerns Identification}
Our managed data framework addresses the problem of \ac{ccc} by capturing them in modular data managers.
Yet, to solve the problem of \ac{ccc} it is first required to identify them in the source code.
This leads to a process called \textit{aspect mining}.
\textit{Aspect mining} is a reverse engineering process that aims at finding \ac{ccc} in existing systems \cite{marin2004identifying}.
The aspect mining topic has been addressed in previous research that include methods such as clone detection \cite{bruntink2005use}, machine learning \cite{shepherd2004design}, IDE tools \cite{robillard2002concern} and more. 
Marin et al. \cite{marin2004identifying} introduced a technique constructed by spotting methods that are invoked from many different places (high fan-in), in order to identify candidate aspects in open-source Java systems.
One of these projects include the JHotDraw.
In this thesis we focused on their concern findings in refactoring JHotDraw.
In particular, we focused on the \textit{FigureSelection}, concern, which is an observer pattern implementation.
% TODO: Undo
% In particular, we focused on two main concerns, the \textit{FigureSelection}, which is an observer pattern implementation and the \textit{Undo} concern that is part of the command pattern.

\section{Aspect Refactoring in Managed Data}
In order to evaluate the ability of managed data to tame aspects, we have refactored the aforementioned concerns of JHotDraw.
More specifically, in this chapter we present the refactoring of the \textit{FigureSelectionListener} observer pattern.
% TODO: Undo
% More specifically, in this chapter we present the refactoring of the \textit{FigureSelectionListener} observer pattern as well as the \textit{Undo} concern.
The choice of those concerns has been made on purpose, since those are the concerns that AJHotDraw refactors using AspectJ and \ac{aop} techniques.
For the refactoring we used our implementation of managed data in Java, presented in the previous chapter.
Therefore, by having three versions of the same application (JHotDraw) and by solving the same concerns we will be able to perform a comparative evaluation.
The three systems included in our assessment are: \textbf{JHotDraw}\footnote{\url{http://www.jhotdraw.org/}}, the original \ac{oop} version, \textbf{AJHotDraw}\footnote{\url{https://sourceforge.net/projects/ajhotdraw/}}, the \ac{aop} refactored version and our \textbf{ManagedDataJHotDraw}\footnote{\url{https://github.com/TheolZacharopoulos/ManagedDataJHotDraw}}, the managed data refactored version.
We focused on those concerns because they were also identified, solved, analyzed and presented in AJHotDraw.
Note that, for compatibility and comparison reliance, we used the version \textit{JHotDraw v.5.4b1} since AJHotDraw also refactors the same version.

In order to refactor JHotDraw, we first had to migrate it in managed data.
The result of this migration is available on an open-source project, the ManagedDataJHotDraw.
We claim that this is the first aspect refactoring of an application using managed data to date, since this project aims on showing how managed data can deal with \ac{ccc} in existing systems.

\section{Migration Process}
The refactoring of an application of JHotDraw's size required a significant amount of time to study and familiarize with, yet, its well-designed \ac{oop} code, made it easy to grasp.
We solely focused on the parts that were going to be refactored, based on refactorings that AJHotDraw developers \cite{marinajhotdraw} performed.
Thanks to their fan-in analysis \cite{marin2004identifying}, we targeted the same concerns in order to make a fair comparison.
Furthermore, during the implementation of ManagedDataJHotDraw we focused on maintaining behavioral coherence and the original design.

\subsection{DrawingView}
One of the main components of JHotDraw is the \textit{DrawingView} interface.
As Figure \ref{fig:JHotDraw_DrawingView} illustrates, the \textit{DrawingView} is responsible for rendering \texttt{Drawings} and listening to its changes.
Additionally, it is responsible for receiving the user input and delegating it to the current tool.

\begin{figure}[H]
	\centering
  	\fbox{\includegraphics[width=.8\textwidth]{figures/JHotDraw_DrawingView.png}}
  	\caption{DrawingView of JHotDraw}
  	\label{fig:JHotDraw_DrawingView}
\end{figure}

Conclusively, \texttt{DrawingView} makes a good candidate for managed data migration.
The reason is that the specifications of that class can be implemented in data managers and dynamically added to it.

\subsection{Managed Data DrawingView}
To support sub-typing on the \texttt{DrawingView} interface, we have implemented the \texttt{MDDrawingView}, namely Managed Data DrawingView, which replaced the \texttt{DrawingView} in JHotDraw.
Having this interface for super type, we still needed the actual managed data schemas.
As Figure \ref{fig:JHotDraw_DrawingView} shows, there are two implementations of the \texttt{DrawingView}.
In particular, the \texttt{StandardDrawingView}, which is the implementation that is used when a new drawing view is created in the application and the \texttt{NullDrawingView}, which represents a null drawing view as for the \textit{null-object} pattern.

Following their original design, we have implemented two schemas, one for the \texttt{StandardDrawingView} and one for the \texttt{NullDrawingView}, namely \texttt{MDStandardDrawingView} and \texttt{MDNullDrawingView} respectively.
The instances of those schemas have been used in the same way their counterparts are used in JHotDraw.
A snippet of the \texttt{MDStandardDrawingView} is shown in Listing \ref{lst:MDStandardDrawingView schema} \footnote{Most of the implementation has been omitted for brevity.}.

\begin{sourcecode}[H]
	\begin{lstlisting}[language=Java, escapechar=|]
public interface MDStandardDrawingView extends M, MDDrawingView { |\label{line:MDStandardDrawingView extends M, MDDrawingView}|
	...
	// Composition over inheritance, the original inherits the JPanel
	JPanel panel(JPanel... panel); |\label{line:jpanel composition}|

	default JPanel getPanel() { |\label{line:jpanel getter}|
	    return panel();
	}

	default void setPanel(JPanel _panel) {|\label{line:jpanel setter}|
	    panel(_panel);
	}
	...
	Rectangle damage(Rectangle... damage);
	Drawing drawing(Drawing... drawing);
	...
	default FigureEnumeration selectionZOrdered() { |\label{line:selectionZOrdered}|
		List result = CollectionsFactory.current().createList(selectionCount());
		FigureEnumeration figures = drawing().figures();

		while (figures.hasNextFigure()) {
			Figure f= figures.nextFigure();
			if (isFigureSelected(f)) {
				result.add(f);
			}
		}
		return new ReverseFigureEnumerator(result);
	}
	...
	default void repairDamage() { |\label{line:repairDamage}|
		if (getDamage() != null) {
			panel().repaint(damage().x, damage().y, damage().width, damage().height);
			setDamage(null);
		}
	}
	...
}
	\end{lstlisting}
	\caption{MDStandardDrawingView schema}
	\label{lst:MDStandardDrawingView schema}
\end{sourcecode}

Listing \ref{lst:MDStandardDrawingView schema} shows that the \texttt{MDStandardDrawingView} interface extends both \texttt{M} interface, defining that this is a schema definition, and \texttt{MDDrawingView}, for sub-type support.
Additionally, all the functionalities implemented in methods of the original \texttt{DrawingView}, in managed data they are implemented in default methods of the schema interface.
The fields of a schema can provide those methods with the managed object's current state.
As Lines \ref{line:selectionZOrdered} and \ref{line:repairDamage} show, the fields of the schema can be used to query their values inside the default methods.
Note that the code in the default methods is identical to the original \texttt{DrawingView}.
Furthermore, for consistency with the legacy code, we have implemented setters and getters, Lines \ref{line:jpanel setter} and \ref{line:jpanel getter}, for field values accessors.
This way we maintained consistency across in accessing values of the managed object.

A notable issue is that the original \texttt{StandardDrawingView} extends the \texttt{javax.swing.jpanel} class as Figure \ref{fig:JHotDraw_DrawingView} shows.
However, such a structure is not supported in managed data. 
Schema definitions can not extend classes.
To overcome this issue we defined the \texttt{JPanel} as a field in the schema, namely \textit{panel}.
To support the \texttt{JPanel} as a type of a field though, it is needs ti be defined as managed data.
By all means, the same holds for the remaining fields, such as \texttt{Rectangle} and \texttt{Drawing}.

As explained in Section \ref{Primitives Definition}, our framework provides external primitives definition by inheriting the \texttt{Primitives} interface.
The JHotDraw primitives definition is shown in Listing \ref{lst:JHotDraw Primitives Definition}.

\begin{sourcecode}[H]
	\begin{lstlisting}[language=Java, escapechar=|]
public interface JHotDrawPrimitives extends Primitives {
	javax.swing.JPanel JPanel();

	java.awt.Color Color();
	java.awt.Cursor Cursor();
	java.awt.Point Point();
	java.awt.Dimension Dimension();
	java.awt.Rectangle Rectangle();

	CH.ifa.draw.framework.DrawingEditor DrawingEditor();
	CH.ifa.draw.framework.Drawing Drawing();
	CH.ifa.draw.framework.Painter Painter();
	CH.ifa.draw.framework.PointConstrainer PointConstrainer();

	CH.ifa.draw.framework.Handle Handle();
	CH.ifa.draw.framework.Figure Figure();
}
	\end{lstlisting}
	\caption{JHotDraw Primitives Definition}
	\label{lst:JHotDraw Primitives Definition}
\end{sourcecode}

This has been proven very helpful since we did not need to re-implement every field as managed data during the refactoring. 
Especially, classes that are provided by libraries such as \texttt{javax.swing} and \texttt{java.awt}.

\subsubsection{Limitations}
However, extending our framework's primitives with the JHotDrawPrimitives we lost the ``pureness'' of managed data.
That led to an application that partly managed data.
Generally, this may be the case when refactoring big applications like JHotDraw.

Another limitation is that some Java keywords such as ``synchronized'' can not be supported on default methods.
Instead, as future work, we could use annotations that define these properties to the default methods and add them during the interpretation of the schemas.
Moreover, privacy is another an issue.
All default methods are \texttt{public}, which means that the encapsulation is violated.
Finally, private classes definition is not possible inside schemas, although they can be defined outside as managed data.

\subsection{MDDrawingView Schema Factories}
In order to create instances of the defined \texttt{MDStandardDrawingView} and \texttt{MDNullDrawingView} schemas, we needed their factories.
Besides the schema factories, which is as simple as Listing \ref{lst:DrawingViewSchemaFactory} shows, we still needed a way to give initialization values to the schema instances the same way that the original \texttt{StandardDrawingView} does during construction.
Additionally, this factory should be used like Java's \texttt{new} keyword in the source code.
This factory just replicates the original \texttt{StandardDrawingView} constructor and is used from the program to create new instances of the schemas.
The code of the \texttt{MDStandardDrawingView} \textit{instances factory} is illustrated in Listing \ref{lst:MDStandardDrawingView Instances Factory}, in comparison to the original constructor, illustrated in Listing \ref{lst:DrawingView Constructor}.

\begin{sourcecode}[H]
	\begin{lstlisting}[language=Java, escapechar=|]
public interface DrawingViewSchemaFactory {
	MDStandardDrawingView DrawingView();
	MDNullDrawingView NullDrawingView();
}
	\end{lstlisting}
	\caption{DrawingView Schema Factory}
	\label{lst:DrawingViewSchemaFactory}
\end{sourcecode}

\begin{sourcecode}[H]
	\begin{lstlisting}[language=Java, escapechar=|]
public StandardDrawingView(DrawingEditor editor, int width, int height) {
	setAutoscrolls(true);
	fEditor = editor;
	fViewSize = new Dimension(width,height);
	setSize(width, height);
	fSelectionListeners = CollectionsFactory.current().createList();
	addFigureSelectionListener(editor()); |\label{line:addFigureSelectionListener_contructor}|
	setLastClick(new Point(0, 0));
	fConstrainer = null;
	fSelection = CollectionsFactory.current().createList();
	setDisplayUpdate(createDisplayUpdate());
	setBackground(Color.lightGray);
	addMouseListener(createMouseListener());
	addMouseMotionListener(createMouseMotionListener());
	addKeyListener(createKeyListener());
}
	\end{lstlisting}
	\label{lst:DrawingView Constructor}
	\caption{Original StandardDrawingView Constructor}
\end{sourcecode}

\begin{sourcecode}[H]
	\begin{lstlisting}[language=Java, escapechar=|]
public static MDDrawingView newDrawingView(
	DrawingEditor editor, int width, int height) {
	final MDStandardDrawingView drawingView = drawingViewSchemaFactory.DrawingView();
	MyJPanel jPanel = new MyJPanel();
	jPanel.setAutoscrolls(true);
 	jPanel.setSize(width, height);
	jPanel.setBackground(Color.lightGray);
	drawingView.panel(jPanel);
	jPanel.setDrawingView(drawingView);

	drawingView.editor(editor);
	drawingView.size(new Dimension(width, height));
	jPanel.setSize(width, height);
	drawingView.lastClick(new Point(0, 0));
	drawingView.constrainer(null);
	drawingView.setDisplayUpdate(new SimpleUpdateStrategy());
	drawingView.setBackground(Color.lightGray);
	drawingView.drawing(new StandardDrawing());

	jPanel.addMouseListener(...);
	jPanel.addMouseMotionListener(...);
	jPanel.addKeyListener(...);
	return drawingView;
}
	\end{lstlisting}
	\label{lst:MDStandardDrawingView Instances Factory}
	\caption{MDStandardDrawingView Instances Factory}
\end{sourcecode}

\subsection{MDDrawingView Integration}
Finally, in order to integrate the \texttt{MDDrawingView} managed objects in the existing system, first we had to replace every instance of \texttt{DrawingView} with \texttt{MDDrawingView}, every \texttt{StandardDrawingView} with \texttt{MDStandardDrawingView} and every \texttt{NullDrawingView} with \texttt{MDNullDrawingView} accordingly.
In addition, everywhere a new instance of these is created, we replaced it with our \textit{instances factory}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Aspect Refactoring of JHotDraw}
Aspect refactoring usually refers to the refactoring of legacy code in aspect oriented code. 
However, in this section we present an aspect refactoring of JHotDraw legacy code in managed data.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% FigureSelectionListener
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{FigureSelectionListener}
The \texttt{FigureSelectionListener} observer pattern of JHotDraw is a concern first presented by Hannemann et al. \cite{hannemann2005role} in their role-based refactoring of design patterns in AspectJ. 
Later, Marin et al. used the same concern and migrated it into their AJHotDraw implementation \cite{marin2005approach}.
Likewise, we have also implemented the same aspect for our refactoring in order to compare our aspect solution with the existing one.

\subsection{FigureSelectionListener in JHotDraw}
The original \texttt{FigureSelectionListener} observer pattern of JHotDraw is illustrated in Figure \ref{fig:JHotDraw_FigureSelectionListener_OOP}.

\begin{figure}[H]
	\centering
  	\fbox{\includegraphics[width=1\textwidth]{figures/JHotDraw_FigureSelectionListener_OOP.png}}
  	\caption{FigureSelectionListener in JHotDraw}
  	\label{fig:JHotDraw_FigureSelectionListener_OOP}
\end{figure}

As this figure illustrates, the \texttt{FigureSelectionListener} interface defines the \textit{Observer} role.
The classes that are interested in the changes of selection of figures in a \texttt{DrawingView} implement this interface.
Accordingly, the \texttt{DrawingView} defines the \textit{Subject} role, providing methods for adding and removing figure selection listeners.
Practically, the only class that implements the \textit{Subject} role is \texttt{StandardDrawingView}, while \texttt{NullDrawingView} has an empty implementation.

\texttt{StandardDrawingView} keeps the selection listeners in a list, the \texttt{fSelectionListeners}, and notifies them in the invocation of the \texttt{fireSelectionChanged} method.
This method is called in the methods: \texttt{addToSelection}, \texttt{removeFromSelection}, \texttt{toggleSelection} and \texttt{clearSelection}, which indicate the change of figure selection.
On the observers' side, the figure selection listeners implement the \texttt{figureSelectionChanged} method that is executed in case they have been notified by the subject.

Concluding, as described above, the ``pattern code'' of the observer pattern is scattered in many places, including the list of listeners on the subject, the add / remove methods, along with the pointcut methods that call the method which notifies the listeners.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Refactoring FigureSelectionListener in AJHotDraw}
Marin et al. presented a refactoring of this concern in AJHotDraw \cite{marin2005approach}. 
Their refactoring is illustrated in Figure \ref{fig:JHotDraw_FigureSelectionListener_AOP}. 

\begin{figure}[H]
	\centering
  	\fbox{\includegraphics[width=.8\textwidth]{figures/JHotDraw_FigureSelectionListener_AOP.png}}
  	\caption{FigureSelectionListener in AJHotDraw}
  	\label{fig:JHotDraw_FigureSelectionListener_AOP}
\end{figure}

In their proposed type-based refactoring, they have used two crosscut sorts, namely \textit{role superimposition} and \textit{consistent behavior}.

\subsubsection{Role Superimposition}
As defined by the authors \cite{marin2005classification}, ``the role superimposition refers to the implementation of a specific secondary role or responsibility''.
In the case of \texttt{FigureSelectionListener}, they used it twice, one for each of the roles.
More specifically, they defined an abstract \texttt{GenericRole} and concrete roles, observer and subject which extend the abstract one.

\subsubsection{Consistent Behavior}
According to the authors\cite{marin2005classification}, ``the consistent behavior sort implements a consistent behavior for a number of method elements that can be captured by a natural pointcut''.
In this case it is used to notify the \textit{Observers} of the changes in the \textit{Subject} object.
More specifically, the methods \texttt{addToSelection}, \texttt{removeFromSelection}, \texttt{toggleSelection} and \texttt{clearSelection} are consistent behavior.
They implement it as a pointcut in AspectJ shown in Listing \ref{lst:Consistent Behavior in FigureSelectionListener}.

\begin{sourcecode} [H]
	\begin{lstlisting}[language=AspectJ]
public aspect SelectionChangedNotification {
	pointcut invalidateSelFigure(StandardDrawingView sdw) :
		(   withincode(boolean StandardDrawingView.addToSelectionImpl(Figure)) 
		 || withincode(void StandardDrawingView.removeFromSelection(Figure)))
		&& call(void Figure.invalidate()) 
		&& this(sdw);

	pointcut clear_toggleSelection(StandardDrawingView sdw):
		(execution(void StandardDrawingView.clearSelection()) ||
		 execution(void StandardDrawingView.toggleSelection(Figure)))
		&& this(sdw);

	after(StandardDrawingView sdw): invalidateSelFigure(sdw) {
		sdw.fireSelectionChanged();
	}

	after(StandardDrawingView sdw): clear_toggleSelection(sdw) {
		sdw.fireSelectionChanged();
	}
}
	\end{lstlisting}
	\caption{AJHotDraw: Consistent Behavior in FigureSelectionListener}
	\label{lst:Consistent Behavior in FigureSelectionListener}
\end{sourcecode}

\subsubsection{Benefits and Limitations}
According to the authors \cite{marin2005approach}, such refactoring allows the crosscutting elements to be addressed individually, which leads to a modular solution, and any deviations from the pattern implementation can be addressed separately.

However, as they mention, the definition of pointcuts in order to capture the calls to the notifier is difficult when many consistent behavior instances occur. 
As Listing \ref{lst:StandardDrawingView clearSelection Method} shows, the original \texttt{clearSelection} method in JHotDraw calls \texttt{fireSelectionChanged} under specific conditions.
Considering the \ac{aop} solution of AJHotDraw, Listing \ref{lst:Consistent Behavior in FigureSelectionListener}, this is not the case.
In the pointcut definition, the pattern refactoring solution notifies the observers independently of the condition in the caller.
Although, according to Marin et al. it is potentially harmless in this case, this implementation deviates from the behavior of the original JHotDraw, leading to a harmful, for the functionality, implementation.
Finally, the problem of the unconditional call of a method in a pointcut is clearly a problem of the language.
AspectJ mechanisms do not support such functionality.
But can managed data solve this problem?

\begin{sourcecode}
	\begin{lstlisting}[language=AspectJ, escapechar=|]
public void clearSelection() {
	if (selectionCount() == 0) {
		// avoid unnecessary selection changed event when nothing has to be cleared
		return;
	}
	FigureEnumeration fe = selection();
	while (fe.hasNextFigure()) {
		fe.nextFigure().invalidate();
	}
	...
	fireSelectionChanged();
}
	\end{lstlisting}
	\caption{StandardDrawingView clearSelection Method}
	\label{lst:StandardDrawingView clearSelection Method}
\end{sourcecode}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Refactoring FigureSelectionListener in ManagedDataJHotDraw}
In JHotDraw's original code, the \textit{observer} \texttt{DrawApplication} creates a new \texttt{StandardDrawingView} instance using the \texttt{createDrawingView} method.
During the construction the \texttt{DrawApplication} passes itself to the constructor of the \texttt{StandardDrawingView} and this in turn adds it to its listeners list, using the \texttt{addFigureSelectionListener} method.
This is shown in Line \ref{line:addFigureSelectionListener_contructor} of Listing \ref{lst:DrawingView Constructor}.
Likewise, the rest of the classes that implement the \texttt{FigureSelectionListener} interface, perform the same mechanism, adding or removing themselves from the \texttt{DrawingView} \textit{Subject}.
Consequently, the pattern code is scattered among all of its participants.

In this section we present our managed data refactoring of the \texttt{FigureSelectionListener} concern.
Managed data implements aspects using data managers, by adding specifications to the data.
For this case, we needed a similar mechanism to the \textit{role superimposition} of \ac{aop}.
This mechanism should be defined in a data manager that will produce managed data instances (managed objects) with a specific role.
Additionally, the data manager has to support something similar to the \textit{consistent behavior} as a pointcut.

In detail, since the \texttt{DrawingView} is managed data, and it is the \textit{Subject} to the \textit{Listeners} of the \textit{FigureSelectionListener} case, we can implement a data manager that attaches the \textit{Subject} \texttt{MDStandardDrawingView}.
Therefore, no \textit{Subject} role specific code will be tangled with the \texttt{DrawingView}, but a data manager will attach this role later.

More specifically, we needed a data manager that performs the following:

\begin{enumerate}
	\item Attaches the \textit{Subject} role to the \texttt{MDStandardDrawingView} since this object implements the pattern.
	Initially, \texttt{MDStandardDrawingView} has no \textit{Subject} role related code.

	\item Enables the \textit{Subject} to \textit{add} and \textit{remove} listener objects to and from itself. 
	\newline
	In this case the \texttt{FigureSelectionListeners}.

	\item Defines an \textit{Action} that will be executed on the listeners in case of the \textit{Subject}'s notification.
	\newline
	In this case the code in the \texttt{figureSelectionChanged()} method.

	\item Finally, it defines a pointcut for the consistent behavior that executes the actions on the listeners. 
	In this case the \texttt{addToSelection}, \texttt{removeFromSelection}, \texttt{toggleSelection} and \texttt{clearSelection} methods.
\end{enumerate}

\subsubsection{Data manager}
As it is mentioned in Chapter \ref{Implementation}, the role of a data manager class is to create a \texttt{MObject}, which interprets and handles a managed object instance.
First, this \texttt{MObject} namely FigureSelectionListenerSubjectRole MObject had to implement our specifications.
In this case the specification was the \textit{Subject} role.

\subsubsection{SubjectRole specification}
We define the functionality of the \textit{SubjectRole} in an interface, shown in Figure \ref{lst:SubjectRole Interface}.
The subject role simply needs to add and remove listener object to and from a managed object.

\begin{sourcecode} [H]
	\begin{lstlisting}[language=Java, escapechar=|]
public interface SubjectRole {
	void addListener(Object listener, Action action);
	void removeListener(Object listener);
}
	\end{lstlisting}
	\caption{SubjectRole Interface}
	\label{lst:SubjectRole Interface}
\end{sourcecode}

\subsubsection{Action}
Additional to the listener object a \textit{SubjectRole} has to define an \textit{Action} for that listener.
That \textit{Action} determines the method which will be executed in that \textit{Listener} in case a notification is retrieved from the \textit{Subject}.
As Listing \ref{lst:Action Interface} shows, this is simply a functional interface that represents an executable action.

\begin{sourcecode} [H]
	\begin{lstlisting}[language=Java, escapechar=|]
@FunctionalInterface
public interface Action {
	void execute();
}
	\end{lstlisting}
	\caption{Action Interface}
	\label{lst:Action Interface}
\end{sourcecode}

\subsubsection{Consistent Behavior Pointcut}
Next, as with the \ac{aop} version, we also needed to define the pointcut for the consistent behavior concern sort.
For practical reasons, we used an interface to define them.
As Figure \ref{lst:FigureSelectionPointcut} shows, a list of the methods that execute the \texttt{Action} for each listener, are defined in the \texttt{FigureSelectionPointcut} interface. 

\begin{sourcecode} [H]
	\begin{lstlisting}[language=Java, escapechar=|]
public interface FigureSelectionPointcut {
	void addToSelection(Figure figure);
	void removeFromSelection(Figure figure);
	void toggleSelection(Figure figure);
	void clearSelection();
}
	\end{lstlisting}
	\caption{FigureSelectionPointcut Interface}
	\label{lst:FigureSelectionPointcut}
\end{sourcecode}

\subsubsection{FigureSelectionListenerSubjectRole MObject}
Finally, having all of our specifications in place, we needed to implement the actual MObject that uses them.
In particular, the FigureSelectionListenerSubjectRole MObject implements those specifications and provides its managed objects with the ability to use them.

\paragraph{Role Superimposition}\mbox{}\\
The implementation of the FigureSelectionListenerSubjectRole MObject is presented in Listing \ref{lst:FigureSelectionListenerSubjectRoleMObject}.
First, the FigureSelectionListenerSubjectRoleMObject extends the MObject, inheriting the functionalities of the base data manager, followed by the implementation of the \texttt{SubjectRole} specifications.
By implementing the \texttt{SubjectRole} interface, the MObject has to implement the \texttt{addListener} and \texttt{removeListener} methods that provide the subject role specifications.
Having added a listener object along with its \texttt{Action} to be executed on each notification, the method \texttt{executeListenerActions} executes all the actions for each of the listeners.
Since we have implemented a form of \textit{role superimposition} what is left is the \textit{consistent behavior} pointcut.

\paragraph{Consistent Behavior Pointcut}\mbox{}\\
Considering that an MObject is an Invocation Handler, every method invocation passes through that object first.
By defining the pointcut in an interface and extending that interface in this MObject, we proxy the execution of the real object's methods, starting with MObject first.
This allows the programmer to add functionalities in these methods which in other cases would scatter the real object's methods.
Similarly to the \ac{aop} solution, the pointcut includes the three methods that call the \texttt{fireSelectionChanged} method.
However, in managed data, we are not limited to a specific method of a class but to an \texttt{Action} passed for the specific listener.
Invoking the \texttt{executeListenerActions} method on each of the methods defined by the pointcut, we have implemented the concern as a modular aspect.

\paragraph{Conditions in Pointcuts}\mbox{}\\
As it has been seen from the \ac{aop} solution, during the pointcut definition, the language did not allow to add any kind of conditions or other functionalities based on the state of the object.
However, since the MObject is proxied to a \texttt{MDStandardDrawingView} instance, the programmer can access the current state of the instance inside the data manager implementation.
Therefore, the programmer can use the state of the program.
In this case, the execution of the action on the listener is performed under a specific condition, (Line \ref{line:fig_lis_mobj_clear} of Listing \ref{lst:FigureSelectionListenerSubjectRoleMObject}), which is similar to the one defined on the original program \ref{lst:StandardDrawingView clearSelection Method}.

\begin{sourcecode} [H]
	\begin{lstlisting}[language=Java, escapechar=|]
public class FigureSelectionListenerSubjectRoleMObject 
	extends MObject implements FigureSelectionPointcut, SubjectRole { |\label{line:fig_lis_mobj_extends}|
	private Map<Object, Action> listeners;
	...
	private void executeListenerActions() { |\label{line:fig_lis_mobj_execute}|
		listeners.values().forEach(Action::execute);
	}

	public void addToSelection(Figure figure) {
		executeListenerActions();
	}

	public void removeFromSelection(Figure figure) {
		executeListenerActions();
	}

	public void toggleSelection(Figure figure) {
		executeListenerActions();
	}

	public void clearSelection() { |\label{line:fig_lis_mobj_clear}|
		if (((MDStandardDrawingView) this.getProxy()).selectionCount() > 0) {
			executeListenerActions();
		}
	}

	public void addListener(Object listener, Action action) {
		listeners.put(listener, action);
	}

	public void removeListener(Object listener) {
		listeners.remove(listener);
	}
}
	\end{lstlisting}
	\caption{FigureSelectionListenerSubjectRoleMObject}
	\label{lst:FigureSelectionListenerSubjectRoleMObject}
\end{sourcecode}

\begin{figure}
	\centering
  	\fbox{\includegraphics[width=1\textwidth]{figures/JHotDraw_FigureSelectionListener_MD.png}}
  	\caption{FigureSelectionListener in ManagedDataJHotDraw}
  	\label{fig:JHotDraw_FigureSelectionListener_MD}
\end{figure}

\subsection{Results}
Figure \ref{fig:JHotDraw_FigureSelectionListener_MD} illustrates the refactored version of the FigureSelectionListener concern in ManagedDataJHotDraw.
Comparing it to the original, Figure \ref{fig:JHotDraw_FigureSelectionListener_OOP}, it can be seen that, first, the list of listeners has been removed from the \texttt{DrawingView}. 
Next, the \texttt{addListener} and \texttt{removeListener} methods have also been removed from the class.
Every call of the \texttt{fireSelectionChanged} method in the pointcut methods has also been omitted.
Finally, conditions on the pointcuts have been defined, something that is not supported by the \ac{aop} version, AJHotDraw.

The integration of the data manager was executed simply by using our schema factories and adding the listeners during construction.
Most importantly, the behavior of the application remained equivalent to the original.
ManagedDataJHotDraw conserved the behavior of JHotDraw, which we evaluated through its own test suite along with manual tests.

% TODO: Undo
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Undo Concern
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \subsection{Undo Concern}
% The ``Undo'' functionality is used in several places in the original JHotDraw.
% Marin's fan-in analysis \cite{marin2004identifying}, identified about 30 undo activities defined for various elements of JHotDraw. 
% For our assessment we focused on the refactoring of the undo concern in the \textit{ChangeAttributeCommand} class.
% We choose the specific case since is the same that is used by Marin et al. on their Undo refactoring in AJHotDraw \cite{marin2004refactoring}.

% \subsubsection{Undo Concern in JHotDraw}
% The original Undo concern in \textit{ChangeAttributeCommand} of JHotDraw is illustrated in Figure \ref{fig:JHotDraw_Undo_Command_ChangeAttributeCommand_OOP}.

% \begin{figure} [H]
% 	\centering
%   	\fbox{\includegraphics[width=0.8\textwidth]{figures/JHotDraw_Undo_Command_ChangeAttributeCommand_OOP.png}}
%   	\caption{Undo in JHotDraw}
%   	\label{fig:JHotDraw_Undo_Command_ChangeAttributeCommand_OOP}
% \end{figure}

% As this figure illustrates, the Undo concern is used through an implementation of the \textit{Command} design pattern.
% More specifically, every activity in the application is executed though a command.
% This command is represented by the \texttt{Command} interface in the figure. 
% Some of the activities support the undo functionality, which in JHotDraw is implemented in nested (undo) classes.

% In the case of the \textit{ChangeAttributeCommand}, the command is called when an attribute is applied to a figure.
% An attribute can be a color, a font, a url etc.
% When an attribute has been applied using an \textit{ChangeAttributeCommand} object, the object defines its \texttt{UndoActivity} through the \textit{UndoActivity} private class.
% JHotDraw supports repeated undo operations by recording the last executed commands in reversed order. 

% This is the role of the  \texttt{UndoableCommand} class, which wraps the commands that can be undone.
% In particular, this class first gets the the request to execute the command, then, it delegates the command's execution to the wrapped command, and last, acquires a reference to the undo activity associated with the wrapped command and it pushes it into a stack managed by an \texttt{UndoManager} \cite{marin2004refactoring}.

% Therefore, as Marin et al. extracted \cite{marin2004identifying} the Undo concern code is scattered in several places of the Command classes.
% First, the \texttt{myUndoableActivity} field in the \texttt{AbstractCommandClass} along with its accessors, \texttt{getUndoActivity} and \texttt{setUndoActivity} accordingly.
% Next, the private nested classes that are implemented by the most of the concrete commands that support undo.
% In addition, the factory methods, \texttt{createUndoActivity},which create instances of the private classes.
% Finally, the references to the before enumerated elements from non-undo related members.

% \subsubsection{Refactoring Undo in AJHotDraw}
% The refactoring that Marin et al. proposed can be seen in Figure \ref{fig:JHotDraw_Undo_Command_ChangeAttributeCommand_AOP}.

% \begin{figure} [H]
% 	\centering
%   	\fbox{\includegraphics[width=0.65\textwidth]{figures/JHotDraw_Undo_Command_ChangeAttributeCommand_AOP.png}}
%   	\caption{Undo in AJHotDraw}
%   	\label{fig:JHotDraw_Undo_Command_ChangeAttributeCommand_AOP}
% \end{figure}

% As the figure shows, a new aspect is created for the \textit{ChangeAttributeCommand}.
% In this aspect the entire undo functionality is implemented and the undo code is removed from the actual \textit{ChangeAttributeCommand} class. 
% Additionally, the private class that implements the \textit{UndoActivity} has moved to this aspect along with its factory method (\textit{createUndoActivity}).
% However, by convention, each aspect will consistently be named by appending ``UndoActivity'' to the name of its associated command class to enforce the relation between the two.
% All the abstract undo functionality has been defined in a \textit{CommandUndo} aspect.
% This aspect defined the undo as a role while it defines the \textit{Undoable} field and its accessors of the \textit{AbstractCommand}.

% \subsubsection{Refactoring Undo in ManagedDataJHotDraw}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Claims
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Claims}
We claim that our framework successfully performed aspect refactoring of the \texttt{FigureSelectionListener} concern in JHotDraw.
Further, it evolved the pointcut concept of \ac{aop} by adding conditions on them.
This leads to a solution that focuses on behavior conservation, lost in the case of the \ac{aop} refactoring.
Finally, although it is moderately easy to migrate an existing application in managed data, it is still time consuming with a lot of boilerplate code if one wants to make everything managed data.

% !TEX root = ../thesis.tex

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Chapter: Aspect refactoring 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Taming Aspects of JHotDraw with managed data}\label{AspectRefactoring}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Crosscutting Concerns Identification}
Our managed data framework addresses the problem of \ac{ccc} by capturing them in modular data managers.
Yet, to solve the problem of \ac{ccc} it is first required to identify them in the source code.
This leads to a process called \textit{aspect mining}.
\textit{Aspect mining} is a reverse engineering process that aims at finding \ac{ccc} in existing systems \cite{marin2004identifying}.
The aspect mining topic has been addressed from several research contribution that included methods such as clone detection \cite{bruntink2005use}, machine learning \cite{shepherd2004design}, IDE tools \cite{robillard2002concern} and more. 
Marin et al. \cite{marin2004identifying} introduced a technique which constructed by spotting methods that are invoked from many different places (high fan-in) in order to identify candidate aspects in open-source Java systems.
One of these projects included the JHotDraw.
In this thesis we chose their concern findings as our focus to refactor in JHotDraw.
In particular, we focused on two main concerns, the \textit{FigureSelection}, which is an observer pattern implementation and the \textit{Undo} concern that is part of the command pattern.

\section{Aspect Refactoring in Managed Data}
In order to evaluate the ability of managed data to tame aspects, we have refactored the aforementioned concerns of JHotDraw.
More specifically, in this chapter we present the refactoring of the \textit{FigureSelectionListener} observer pattern as well as the \textit{Undo} concern.
The choice of those concerns has been made on purpose since those are the concerns that AJHotDraw refactors using AspectJ and \ac{aop} techniques.
For the refactoring we used our implementation of managed data in Java that presented in the previous chapter.
Therefore, by having three versions of the same application (JHotDraw) and by solving the same concerns, this will provide us with better assessment methods for their comparison.
The three systems that participate our assessment are: \textbf{JHotDraw}\footnote{\url{http://www.jhotdraw.org/}}, the original \ac{oop} version, \textbf{AJHotDraw}\footnote{\url{https://sourceforge.net/projects/ajhotdraw/}}, the \ac{aop} refactored version and our \textbf{ManagedDataJHotDraw}\footnote{\url{https://github.com/TheolZacharopoulos/ManagedDataJHotDraw}}, the managed data refactored version.
We focused on those concerns because they have also identified, solved, analyzed and presented in AJHotDraw.
Note that, for compatibility and comparison reliance, we used the version \textit{JHotDraw v.5.4b1} since AJHotDraw also refactors the same version.

In order to refactor JHotDraw, we first had to migrate in managed data.
The result of this migration is available to an open-source project the ManagedDataJHotDraw.
We claim that this is the first aspect refactoring of an application using managed data to date since this project aims on showing how managed data can deal with \ac{ccc} in existing systems.

\section{Migration Process}
The refactoring of an application with JHotDraw's size required a significant amount of time to study and familiarizing with, yet, its well-designed \ac{oop} code, made it easy to grasp.
In particular, we focused only on the parts that we were going to refactor since we wanted to assess the same refactorings that AJHotDraw developers \cite{marinajhotdraw} did.
Thanks to their fan-in analysis \cite{marin2004identifying}, we targeted the same concerns in order to make a fair comparison.
Furthermore, during the implementation of ManagedDataJHotDraw we focused on maintaining behavioral coherence and the original design.

\subsection{DrawingView}
One of main components of the JHotDraw architecture is the \textit{DrawingView} interface.
As Figure \ref{fig:JHotDraw_DrawingView} illustrates, the \textit{DrawingView} is responsible of rendering \texttt{Drawings} and listens to its changes.
Additionally, is responsible for receiving the user input and delegate it to the current tool.

\begin{figure}[H]
	\centering
  	\fbox{\includegraphics[width=1\textwidth]{figures/JHotDraw_DrawingView.png}}
  	\caption{DrawingView of JHotDraw}
  	\label{fig:JHotDraw_DrawingView}
\end{figure}

The fact that \texttt{DrawingView} plays a significant role along with its subject / observer properties, makes it a good candidate for manage data migration.
The reason is that the specifications of that class can be implemented as data managers and added dynamically to it.

\subsection{Managed Data DrawingView}
To support sub-typing on the \texttt{DrawingView} interface, we have implemented the \texttt{MDDrawingView}, namely Managed Data DrawingView, which substituted the \texttt{DrawingView} in JHotDraw.
Having this interface for super type, we still needed the actual managed data schemas.
As Figure \ref{fig:JHotDraw_DrawingView} shows, there are two implementations of the \texttt{DrawingView}.
In particular, the \texttt{StandardDrawingView}, which is the implementation that is used when a new drawing view is created in the application and the \texttt{NullDrawingView}, which represents a null drawing view as for the \textit{null-object} pattern.

Following their original design, we have implemented two schemas, one for the \texttt{StandardDrawingView} and one for the \texttt{NullDrawingView}, namely \texttt{MDStandardDrawingView} and \texttt{MDNullDrawingView} respectively.
The instances of those schemas have been used in the same way their counterparts used in JHotDraw.
A snippet of the \texttt{MDStandardDrawingView} is shown in Listing \ref{lst:MDStandardDrawingView schema} \footnote{Most of the implementation has been omitted for brevity.}.

\begin{sourcecode}[H]
	\begin{lstlisting}[language=Java, escapechar=|]
public interface MDStandardDrawingView extends M, MDDrawingView { |\label{line:MDStandardDrawingView extends M, MDDrawingView}|
	...
	// Composition over inheritance, the original inherits the JPanel
	JPanel panel(JPanel... panel); |\label{line:jpanel composition}|

	default JPanel getPanel() { |\label{line:jpanel getter}|
	    return panel();
	}

	default void setPanel(JPanel _panel) {|\label{line:jpanel setter}|
	    panel(_panel);
	}
	...
	Rectangle damage(Rectangle... damage);
	Drawing drawing(Drawing... drawing);
	...
	default FigureEnumeration selectionZOrdered() { |\label{line:selectionZOrdered}|
		List result = CollectionsFactory.current().createList(selectionCount());
		FigureEnumeration figures = drawing().figures();

		while (figures.hasNextFigure()) {
			Figure f= figures.nextFigure();
			if (isFigureSelected(f)) {
				result.add(f);
			}
		}
		return new ReverseFigureEnumerator(result);
	}
	...
	default void repairDamage() { |\label{line:repairDamage}|
		if (getDamage() != null) {
			panel().repaint(damage().x, damage().y, damage().width, damage().height);
			setDamage(null);
		}
	}
	...
}
	\end{lstlisting}
	\caption{MDStandardDrawingView schema}
	\label{lst:MDStandardDrawingView schema}
\end{sourcecode}

Listing \ref{lst:MDStandardDrawingView schema} shows that the \texttt{MDStandardDrawingView} interface extends both \texttt{M}, defining that this is a schema definition, and \texttt{MDDrawingView} for sub-type support.
Additionally, all the functionality implemented in methods of the original \texttt{DrawingView}, in managed data is implemented in default methods of the schema interface.
The fields of a schema can provide those methods with the managed object's current state.
As Lines \ref{line:selectionZOrdered} and \ref{line:repairDamage} show, the fields of the schema can be used to query their values inside the default methods.
Note that the code in the defaults methods is identical to the original \texttt{DrawingView}.
Furthermore, for consistency with the legacy code, we have implemented setters and getters, Lines \ref{line:jpanel setter} and \ref{line:jpanel getter}, for field values accessors.
This way we kept consistent the way the other object access values of the managed object.

A notably issue is that the original \texttt{StandardDrawingView} extends the \texttt{javax.swing.jpanel} class as Figure \ref{fig:JHotDraw_DrawingView} shows.
However, such a structure is not supported in managed data. 
Schema definitions can not extend classes.
To overcome this issue we defined the \texttt{JPanel} as a field in the schema, named \textit{panel}.
To support the \texttt{JPanel} as a type of a field though, it needed to be also defined as managed data.
The same holds of course for the rest of the fields such as \texttt{Rectangle} and \texttt{Drawing}.

As explained in Section \ref{Primitives Definition}, our framework provides with external primitive definitions by inheriting the \texttt{Primitives} interface.
The JHotDraw primitive definitions is showed in Listing \ref{lst:JHotDraw Primitives Definition}.

\begin{sourcecode}[H]
	\begin{lstlisting}[language=Java, escapechar=|]
public interface JHotDrawPrimitives extends Primitives {
	javax.swing.JPanel JPanel();

	java.awt.Color Color();
	java.awt.Cursor Cursor();
	java.awt.Point Point();
	java.awt.Dimension Dimension();
	java.awt.Rectangle Rectangle();

	CH.ifa.draw.framework.DrawingEditor DrawingEditor();
	CH.ifa.draw.framework.Drawing Drawing();
	CH.ifa.draw.framework.Painter Painter();
	CH.ifa.draw.framework.PointConstrainer PointConstrainer();

	CH.ifa.draw.framework.Handle Handle();
	CH.ifa.draw.framework.Figure Figure();
}
	\end{lstlisting}
	\caption{JHotDraw Primitives Definition}
	\label{lst:JHotDraw Primitives Definition}
\end{sourcecode}

This has been proven very helpful since we did not need to re-implement every field as managed data during the refactoring. 
Especially classes that are provided by libraries such as \texttt{javax.swing} and \texttt{java.awt}.

\subsubsection{Limitations}
However, extending our framework's primitives with the JHotDrawPrimitives we lost the ``pureness'' of managed data.
That led to an application that part of it is managed data but part of it is not.
Generally, that may be the case when refactoring big, in size, applications like JHotDraw.

Another limitation is that some Java keywords such as ``Synchronized'' can not be supported on default methods.
Instead, as future work, we could use annotations that define these properties to the default methods and add them during the interpretation of the schemas.
Moreover, privacy is also an issue.
All default methods are \texttt{public}, which means that the encapsulation is violated.
Finally, private classes definition is not possible in schemas, although they can be defined outside as managed data.

\subsection{MDDrawingView Schema Factories}
In order to create instances of the defined \texttt{MDStandardDrawingView} and \texttt{MDNullDrawingView} schemas, we needed their factories.
Besides the schema factories, which is as simple as Listing \ref{lst:DrawingViewSchemaFactory} shows, we still needed a way to give initialization values to the schema instances the same way that the original \texttt{StandardDrawingView} does during construction.
Additionally, this factory should be used like Java's \texttt{new} keyword in the source code.
This factory just replicates the original \texttt{StandardDrawingView} constructor and is used from the program to create new instances of the schemas.
The code of the \texttt{MDStandardDrawingView} \textit{instances factory} is illustrated in Listing \ref{lst:MDStandardDrawingView Instances Factory}, in comparison with the original constructor illustrated in Listing \ref{lst:DrawingView Constructor}.

\begin{sourcecode}[H]
	\begin{lstlisting}[language=Java, escapechar=|]
public interface DrawingViewSchemaFactory {
	MDStandardDrawingView DrawingView();
	MDNullDrawingView NullDrawingView();
}
	\end{lstlisting}
	\caption{DrawingView Schema Factory}
	\label{lst:DrawingViewSchemaFactory}
\end{sourcecode}

\begin{sourcecode}[H]
	\begin{lstlisting}[language=Java, escapechar=|]
public StandardDrawingView(DrawingEditor editor, int width, int height) {
	setAutoscrolls(true);
	fEditor = editor;
	fViewSize = new Dimension(width,height);
	setSize(width, height);
	fSelectionListeners = CollectionsFactory.current().createList();
	addFigureSelectionListener(editor()); |\label{line:addFigureSelectionListener_contructor}|
	setLastClick(new Point(0, 0));
	fConstrainer = null;
	fSelection = CollectionsFactory.current().createList();
	setDisplayUpdate(createDisplayUpdate());
	setBackground(Color.lightGray);
	addMouseListener(createMouseListener());
	addMouseMotionListener(createMouseMotionListener());
	addKeyListener(createKeyListener());
}
	\end{lstlisting}
	\label{lst:DrawingView Constructor}
	\caption{Original StandardDrawingView Constructor}
\end{sourcecode}

\begin{sourcecode}[H]
	\begin{lstlisting}[language=Java, escapechar=|]
public static MDDrawingView newDrawingView(
	DrawingEditor editor, int width, int height) {
	final MDStandardDrawingView drawingView = drawingViewSchemaFactory.DrawingView();
	MyJPanel jPanel = new MyJPanel();
	jPanel.setAutoscrolls(true);
 	jPanel.setSize(width, height);
	jPanel.setBackground(Color.lightGray);
	drawingView.panel(jPanel);
	jPanel.setDrawingView(drawingView);

	drawingView.editor(editor);
	drawingView.size(new Dimension(width, height));
	jPanel.setSize(width, height);
	drawingView.lastClick(new Point(0, 0));
	drawingView.constrainer(null);
	drawingView.setDisplayUpdate(new SimpleUpdateStrategy());
	drawingView.setBackground(Color.lightGray);
	drawingView.drawing(new StandardDrawing());

	jPanel.addMouseListener(...);
	jPanel.addMouseMotionListener(...);
	jPanel.addKeyListener(...);
	return drawingView;
}
	\end{lstlisting}
	\label{lst:MDStandardDrawingView Instances Factory}
	\caption{MDStandardDrawingView Instances Factory}
\end{sourcecode}

\subsection{MDDrawingView Integration}
Finally, in order to integrate the MDDrawingView managed objects in the existing system, first we had to replace every instance of \texttt{DrawingView} with \texttt{MDDrawingView}, every \texttt{StandardDrawingView} with \texttt{MDStandardDrawingView} and every \texttt{NullDrawingView} with \texttt{MDNullDrawingView} accordingly.
In addition, each place that a new instance of these is created, we replaced it with our \textit{instances factory}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Aspect Refactoring of JHotDraw}
Aspect refactoring usually refers to the refactoring of legacy in aspect oriented code. 
However, in this section we present an aspect refactoring of JHotDraw legacy code in managed data.

\subsection{FigureSelectionListener}
The \texttt{FigureSelectionListener} observer pattern of JHotDraw is a concern that first presented by Hannemann et al. \cite{hannemann2005role} in their role-based refactoring of design patterns in AspectJ. 
Later Marin et al. used the same concern and migrated it to their AJHotDraw implementation \cite{marin2005approach}.
Likewise, we have also implemented the same aspect for our refactoring in order to assess our aspect solution with the existing one.

\subsection{FigureSelectionListener in JHotDraw}
The original \texttt{FigureSelectionListener} observer pattern of JHotDraw is illustrated in Figure \ref{fig:JHotDraw_FigureSelectionListener_OOP}.

\begin{figure}[H]
	\centering
  	\fbox{\includegraphics[width=1\textwidth]{figures/JHotDraw_FigureSelectionListener_OOP.png}}
  	\caption{FigureSelectionListener in JHotDraw}
  	\label{fig:JHotDraw_FigureSelectionListener_OOP}
\end{figure}

As this figure illustrates, the \texttt{FigureSelectionListener} interface defines the \textit{Observer} role.
The classes that are interested in the changes of selection of figures in a \texttt{DrawingView}, implement this interface.
Accordingly, the \texttt{DrawingView} defines the \textit{Subject} role providing methods for adding and removing figure selection listeners.
Practically, the only class that implements the \textit{Subject} role is \texttt{StandardDrawingView}, while \texttt{NullDrawingView} has an empty implementation.

\texttt{StandardDrawingView} keeps the selection listeners in a list, the \texttt{fSelectionListeners}, and notifies the listeners in the invocation of the \texttt{fireSelectionChanged} method.
This method is called in the methods: \texttt{addToSelection}, \texttt{removeFromSelection}, \texttt{toggleSelection} and \texttt{clearSelection}, which indicate the change of figure selection.
On the observers' side, the figure selection listeners implement the \texttt{figureSelectionChanged} method that is executed in case they have been notified by the subject.

Concluding, as shown the ``pattern code'' of the observer pattern is scattered in many places, including the list of listeners on the subject, the add / remove methods, along with the pointcut methods that call the method which notifies the listeners.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Refactoring FigureSelectionListener in AJHotDraw}
Marin et al. presented a refactoring of this concern in AJHotDraw \cite{marin2005approach}. 
Their refactoring is illustrated in Figure \ref{fig:JHotDraw_FigureSelectionListener_AOP}. 

\begin{figure}[H]
	\centering
  	\fbox{\includegraphics[width=.8\textwidth]{figures/JHotDraw_FigureSelectionListener_AOP.png}}
  	\caption{FigureSelectionListener in AJHotDraw}
  	\label{fig:JHotDraw_FigureSelectionListener_AOP}
\end{figure}

In their proposed type-based refactoring, they have used two crosscut sorts, namely \textit{role superimposition} and \textit{consistent behavior}.

\subsubsection{Role Superimposition}
As defined by the authors \cite{marin2005classification}, ``the role superimposition refers to the implementation of a specific secondary role or responsibility''.
In the case of \texttt{FigureSelectionListener}, they used it twice, one for each of the roles.
More specifically, they defined an abstract \texttt{GenericRole} and concrete roles, observer and subject extend which extend the abstract one.

\subsubsection{Consistent Behavior}
According to the authors\cite{marin2005classification}, ``the consistent behavior sort implements a consistent behavior for a number of method elements that can be captured by a natural pointcut''.
In this case it is used to notify the observers of the changes in the subject object.
More specifically, the methods \texttt{addToSelection}, \texttt{removeFromSelection}, \texttt{toggleSelection} and \texttt{clearSelection} are consisted behavior.
They defined it as a pointcut in AspectJ shown in Listing \ref{lst:Consistent Behavior in FigureSelectionListener}.

\begin{sourcecode} [H]
	\begin{lstlisting}[language=AspectJ]
public aspect SelectionChangedNotification {
	pointcut invalidateSelFigure(StandardDrawingView sdw) :
		(   withincode(boolean StandardDrawingView.addToSelectionImpl(Figure)) 
		 || withincode(void StandardDrawingView.removeFromSelection(Figure)))
		&& call(void Figure.invalidate()) 
		&& this(sdw);

	pointcut clear_toggleSelection(StandardDrawingView sdw):
		(execution(void StandardDrawingView.clearSelection()) ||
		 execution(void StandardDrawingView.toggleSelection(Figure)))
		&& this(sdw);

	after(StandardDrawingView sdw): invalidateSelFigure(sdw) {
		sdw.fireSelectionChanged();
	}

	after(StandardDrawingView sdw): clear_toggleSelection(sdw) {
		sdw.fireSelectionChanged();
	}
}
	\end{lstlisting}
	\caption{AJHotDraw: Consistent Behavior in FigureSelectionListener}
	\label{lst:Consistent Behavior in FigureSelectionListener}
\end{sourcecode}

\subsubsection{Benefits and Limitations}
According to the authors \cite{marin2005approach}, such refactoring has the benefits that the crosscutting elements are addressed individually, which leads to a modular solution and any deviations from the pattern implementation can be addressed separately.

However, as they also mention, the definition of pointcuts to capture the calls to the notifier, as for many consistent behavior instances, is difficult. 
As Listing \ref{lst:StandardDrawingView clearSelection Method} shows, the original \texttt{clearSelection} method in JHotDraw calls \texttt{fireSelectionChanged} under specific conditions.
Considering the \ac{aop} solution of AJHotDraw, Listing \ref{lst:Consistent Behavior in FigureSelectionListener}, this is not the case.
In the pointcut definition, the pattern refactoring solution notifies the observers independently of the condition in the caller.
Although, according to Marin et al. it is potentially harmless in this case, this implementation deviates from the behavior of the original JHotDraw leading to a harmful for the functionality implementation.
Finally, the problem of the unconditional call of the a method in a pointcut is clearly a problem of the language, AspectJ mechanisms do not support such functionality. But can managed data solve this problem?

\begin{sourcecode}
	\begin{lstlisting}[language=AspectJ, escapechar=|]
public void clearSelection() {
	if (selectionCount() == 0) {
		// avoid unnecessary selection changed event when nothing has to be cleared
		return;
	}
	FigureEnumeration fe = selection();
	while (fe.hasNextFigure()) {
		fe.nextFigure().invalidate();
	}
	...
	fireSelectionChanged();
}
	\end{lstlisting}
	\caption{StandardDrawingView clearSelection Method}
	\label{lst:StandardDrawingView clearSelection Method}
\end{sourcecode}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Refactoring FigureSelectionListener in ManagedDataJHotDraw}
In JHotDraw's original code, the \textit{observer} \texttt{DrawApplication} creates a new \texttt{StandardDrawingView} instance using the \texttt{createDrawingView} method.
During the construction the \texttt{DrawApplication} passes itself to the constructor of \texttt{StandardDrawingView} and this in turn adds it to its listeners list, using the \texttt{addFigureSelectionListener} method.
This is shown in Line \ref{line:addFigureSelectionListener_contructor} of Listing \ref{lst:DrawingView Constructor}.
Likewise, the rest of the classes that implement the \texttt{FigureSelectionListener} interface, perform the same mechanism, adding or removing themselves from the \texttt{DrawingView} \textit{Subject}.
Consequently, the pattern code is scattered among all of its participants.

In this section we present our managed data refactoring of the \texttt{FigureSelectionListener} concern.
Managed data implement aspects using data managers adding specifications to the data.
For this case, we needed a similar mechanism to the \textit{role superimposition} of \ac{aop}.
This mechanism should be defined in a data manager that will produce managed data instances (managed objects) with a specific role.
Additionally, the data manager has to support something similar to the \textit{consistent behavior} as a pointcut.

In detail, since the \texttt{DrawingView} is managed data, and it is the \textit{Subject} to the \textit{Listeners} of the \textit{FigureSelectionListener} case, we can implement a data manager that attaches the \textit{Subject} \texttt{MDStandardDrawingView}.
Therefore, no \textit{Subject} role specific code will be tangled with the \texttt{DrawingView}, but a data manager will attach this role later.

More specifically, we needed a data manager that performs the following:

\begin{enumerate}
	\item Attaches the \textit{Subject} role to the \texttt{MDStandardDrawingView} since this is the one that implements the pattern.
	Initially, \texttt{MDStandardDrawingView} has no \textit{Subject} role related code.

	\item Enables the \textit{Subject} to \textit{add} and \textit{remove} listener objects to itself. 
	\newline
	In this case the \texttt{FigureSelectionListeners}.

	\item Defines an \textit{Action} that will be executed to the listeners in case of \textit{Subject}'s notification.
	\newline
	In this case the code in the \texttt{figureSelectionChanged()} method.

	\item Finally, it defines a pointcut for the consistent behavior that execute the actions on the listeners. In this case the \texttt{addToSelection}, \texttt{removeFromSelection}, \texttt{toggleSelection} and \texttt{clearSelection} methods.
\end{enumerate}

\subsubsection{Data manager}
As it is mentioned in Chapter \ref{Implementation}, the role of a data manager class is to create a \texttt{MObject}, which interprets and handles a managed object instance.
First, this \texttt{MObject} namely FigureSelectionListenerSubjectRole MObject had to implement our specifications.
In this case the specification was the \textit{Subject} role.

\subsubsection{SubjectRole specification}
We define the functionality of the \textit{SubjectRole} in an interface, shown in Figure \ref{lst:SubjectRole Interface}.
The subject role simply needs to add and remove listener object to an managed object.

\begin{sourcecode} [H]
	\begin{lstlisting}[language=Java, escapechar=|]
public interface SubjectRole {
	void addListener(Object listener, Action action);
	void removeListener(Object listener);
}
	\end{lstlisting}
	\caption{SubjectRole Interface}
	\label{lst:SubjectRole Interface}
\end{sourcecode}

\subsubsection{Action}
Additional to the listener object a \textit{SubjectRole} has to define an \textit{Action} for that listener.
That \textit{Action} determines the method which will be executed in that \textit{Listener} in case a notification retrieved from the \textit{Subject}.
As Listing \ref{lst:Action Interface} shows, this is just a functional interface that represents an executable action.

\begin{sourcecode} [H]
	\begin{lstlisting}[language=Java, escapechar=|]
@FunctionalInterface
public interface Action {
	void execute();
}
	\end{lstlisting}
	\caption{Action Interface}
	\label{lst:Action Interface}
\end{sourcecode}

\subsubsection{Consistent Behavior Pointcut}
Next, as with the \ac{aop} version, we also needed to define the pointcut for the consistent behavior concern sort.
For practical reasons, we used an interface to define them.
As Figure \ref{lst:FigureSelectionPointcut} shows, a list of the methods that will execute the \texttt{Action} for each listener, are defined in the \texttt{FigureSelectionPointcut} interface. 

\begin{sourcecode} [H]
	\begin{lstlisting}[language=Java, escapechar=|]
public interface FigureSelectionPointcut {
	void addToSelection(Figure figure);
	void removeFromSelection(Figure figure);
	void toggleSelection(Figure figure);
	void clearSelection();
}
	\end{lstlisting}
	\caption{FigureSelectionPointcut Interface}
	\label{lst:FigureSelectionPointcut}
\end{sourcecode}

\subsubsection{FigureSelectionListenerSubjectRole MObject}
Finally, having all of our specifications in place we needed to implement the actual MObject that uses them.
In particular, the FigureSelectionListenerSubjectRole MObject implements those specification and provides its managed objects with the ability of using them.

\paragraph{Role Superimposition}\mbox{}\\
The implementation of the FigureSelectionListenerSubjectRole MObject is presented in Listing \ref{lst:FigureSelectionListenerSubjectRoleMObject}.
First, the FigureSelectionListenerSubjectRoleMObject extends the MObject, inheriting the functionality of the base data manager, followed by the implementation of the \texttt{SubjectRole} specifications.
By implementing the \texttt{SubjectRole} interface, the MObject has to implement the \texttt{addListener} and \texttt{removeListener} methods that provide the subject role functionality.
Having added a listener object along with its \texttt{Action} to be executed on each notification, the method \texttt{executeListenerActions} executes all the actions for each of the listeners.
Since we have implemented a form of \textit{role superimposition} what is left is the \textit{consistent behavior} pointcut.

\paragraph{Consistent Behavior Pointcut}\mbox{}\\
Considering that an MObject is an Invocation Handler, that means that every method invocation passes through that object first.
Defining the pointcut in an interface and extending that interface in this MObject, we proxy the execution of the real object's methods, with these implemented in the MObject first.
This allows the programmer to add functionality in these methods that in other cases would scatter the real object's methods.
Similarly to the \ac{aop} solution, the pointcut includes the three methods that call the \texttt{fireSelectionChanged} method.
However, in managed data, we are not limited to a specific method of a class but to an \texttt{Action} passed for the specific listener.
Invoking the \texttt{executeListenerActions} method on each of the methods defined by the pointcut, we have implemented the concern as a modular aspect.

\paragraph{Conditions in Pointcuts}\mbox{}\\
As it has been seen from the \ac{aop} solution, during the pointcut definition, the language did not allow to add any kind of conditions or other functionality based on the state of the object.
However, since the MObject is proxied to a \texttt{MDStandardDrawingView} instance, the programmer can access the current state of the instance inside the data manager implementation.
Therefore, the programmer can use the state of the program.
In this case, the execution of the action on the listener is performed under specific condition, (Line \ref{line:fig_lis_mobj_clear} of Listing \ref{lst:FigureSelectionListenerSubjectRoleMObject}), this condition is similar with the one defined on the original program \ref{lst:StandardDrawingView clearSelection Method}.

\begin{sourcecode} [H]
	\begin{lstlisting}[language=Java, escapechar=|]
public class FigureSelectionListenerSubjectRoleMObject 
	extends MObject implements FigureSelectionPointcut, SubjectRole { |\label{line:fig_lis_mobj_extends}|
	private Map<Object, Action> listeners;
	...
	private void executeListenerActions() { |\label{line:fig_lis_mobj_execute}|
		listeners.values().forEach(Action::execute);
	}

	public void addToSelection(Figure figure) {
		executeListenerActions();
	}

	public void removeFromSelection(Figure figure) {
		executeListenerActions();
	}

	public void toggleSelection(Figure figure) {
		executeListenerActions();
	}

	public void clearSelection() { |\label{line:fig_lis_mobj_clear}|
		if (((MDStandardDrawingView) this.getProxy()).selectionCount() > 0) {
			executeListenerActions();
		}
	}

	public void addListener(Object listener, Action action) {
		listeners.put(listener, action);
	}

	public void removeListener(Object listener) {
		listeners.remove(listener);
	}
}
	\end{lstlisting}
	\caption{FigureSelectionListenerSubjectRoleMObject}
	\label{lst:FigureSelectionListenerSubjectRoleMObject}
\end{sourcecode}

\begin{figure}
	\centering
  	\fbox{\includegraphics[width=1\textwidth]{figures/JHotDraw_FigureSelectionListener_MD.png}}
  	\caption{FigureSelectionListener in ManagedDataJHotDraw}
  	\label{fig:JHotDraw_FigureSelectionListener_MD}
\end{figure}

\subsection{Results}
Figure \ref{fig:JHotDraw_FigureSelectionListener_MD} illustrates the refactored version of the FigureSelectionListener concern in ManagedDataJHotDraw.
Comparing it with the original, Figure \ref{fig:JHotDraw_FigureSelectionListener_OOP}, it can be seen that, first, the list listeners of listeners have been removed from the \texttt{DrawingView}. 
Next, the \texttt{addListener} and \texttt{removeListener} methods have also removed from the class.
Every call of the \texttt{fireSelectionChanged} method in the pointcut methods has been also omitted.
Finally, conditions on the pointcuts have defined, something that is not supported from the \ac{aop} version, AJHotDraw.

The integration of the data manager was easy, simply by using our schema factories and adding the listeners during construction.
Most importantly the behavior of the application remained equivalent to the original.
ManagedDataJHotDraw conserved the behavior of JHotDraw, which we evaluated through its own test suite along with manual tests.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \subsection{Undo Concern}
% \subsubsection{Undo Concern in JHotDraw}
% \subsubsection{Refactoring Undo in AJHotDraw}
% \subsubsection{Refactoring Undo in ManagedDataJHotDraw}
% TODO: More patterns?

\section{Claims}
We claim that our framework successfully performed aspect refactoring of the \texttt{FigureSelectionListener} concern in JHotDraw.
Additionally, it evolved the pointcut concept of \ac{aop} by adding conditions on them
This leads to a better solution since it focuses on behavior conservation which is lost in the case of the \ac{aop} refactoring.
Finally, although it is moderately easy to migrate an existing application in managed data, it is still time consuming with a lot of boilerplate code if one wants to make everything as managed data.

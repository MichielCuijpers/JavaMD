% !TEX root = ../thesis.tex

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Chapter: Implementation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Managed data in Java}\label{Implementation}

As it has already been mentioned, the programming languages include data definition mechanisms that are predefined. 
This makes them unable to define \ac{ccc} without repeating and scattering code through the components \cite{loh2012managed}.
Notably, the problem is that \ac{ccc} are not considered features of the data types, but instead features of data management.
As a result, we implement managed data to allow the developer to define the mechanisms of data manipulation.
This chapter describes our managed data implementation in Java, testing our first research question, which states \textit{``How to implemented managed data in a static language?''}.
It is important to mention that our implementation is inspired by Enso\footnote{\url{https://github.com/enso-lang/enso}}, which is written in Ruby.
Although Ruby is a dynamic language, Enso significantly contributed to our implementation's design.
In this chapter we preset the implementation of managed data in Java, which is available also online as an open-source project called JavaMD (Java Managed Data)\footnote{\url{https://github.com/TheolZacharopoulos/JavaMD}}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Managed Data Implementation}\label{sec:Managed Data Implementation}
Managed data allows the programmer to handle the fundamental data manipulation mechanisms using \textit{Data Managers}, one of its distinguishing features being modularity.
Using a data description language the programmer defines \textit{Schemas}. 
\textit{Schemas} are the input of \textit{Data Managers}. 
A \textit{Data Manager} in turn interprets the data description language that is used to define the structure and the behavior of the data to be managed.
\textit{Schemas} and \textit{Data Managers} are essential components of managed data, along with \textit{Integration} in the programming language, in our case being Java.

\subsection{Data description with Schemas}\label{Schema Definition}
To create instances of data, we first need to define their structure.
\textit{Schemas} describe the outline structure of our data.
In order to define \textit{Schemas} in managed data we need a data description language that allows to define records as collections of fields.
This language can be anything, e.g. XML, JSON or a different formalism like the one used in Enso.
For our implementation we chose to use \textbf{Java Interfaces} as a data description language to define records of managed data.
By using Java interfaces we use Java's syntax for our definitions.
Moreover, Java interfaces use several conventions to encode semantics, for instance Java annotations, which are very useful for meta data definition on \textit{Schema}s.

As a result, to define a \textit{Schema} we first need to define a set of classes that describe that schema.
A schema \texttt{Klass} \footnote{
	We use the ``Klass'' instead of ``Class'' convention in order to avoid any kind of ambiguities between Java's Class type and our type system. Klass is used to describe our own class type while Class describes Java's native class type.} 
is described by a name and a set of \texttt{Field}s, each of which has a name and a \texttt{Type}.
Since Java interfaces are used to define a \texttt{schemaKlass} we need a way to define \texttt{Field}s for that \texttt{schemaKlass}.
A \texttt{Field} in our data description language can be defined by using \textbf{Java's Method} definition.

Additionally, there are several attributes, considered meta data, that help define the structure of a \texttt{Schema}.
In order to define the meta data in our data description language (interfaces), we use \textit{Java Annotations}.
Annotations are very declarative in the way they express meta data in interfaces and they are consistent with the system (Java).

Thus, to provide a field with meta data, we define annotations in a \textit{Method} target level since a \texttt{Field} is defined by a \textit{Method} declaration Java interfaces.

Note that by using Java interfaces and annotations for our schemas definition, we gain a first level of type checking from \ac{jvm}. 
The reason is that before we run our runtime interpretation of schemas, \ac{jvm} performs type checking in the definitions and in case of wrong types it notifies the programmer.
Additionally, this is beneficial when a programmer uses IDE's that perform real time type inspection\footnote{\url{https://www.jetbrains.com/help/idea/15.0/code-analysis.html}}. 
In those cases errors on the definitions will be spotted immediately. 

The list of the available structure concepts that are supported in our language is presented below \cite{loh2012managed}:
\begin{description}
	\item [@Key] When a method (field definition) is annotated with the \texttt{@Key} annotation that forces its value to be unique within collections of this field's Klass.
	The key should be used on a single field of a Type and its value represents the uniqueness of its Klass's instance.
	Another way to look at this is as a counterpart of the \texttt{hashCode} in traditional Java programs.
	This way when many values of a Klass are in a Set, the key field ensures uniqueness in its context.

	\item [@Inverse] This annotation includes two \textit{annotation element definitions} \footnote{
		\url{https://docs.oracle.com/javase/tutorial/java/annotations/declaring.html}}.
	When a method is annotated with the \texttt{@Inverse(Class other, String field)} annotation, then the inverse \texttt{field} element must be a \texttt{Field}'s name in the \texttt{Class} interface, given by the \texttt{type} element.
	This meta data is used as a reference declaration in schemas, meaning that when a programmer updates the value of a field that is annotated with inverse, then the value of the field that refers to will be also updated.
	This mechanism is interpreted by the managed object and is used for automated \textit{wiring} of the field across a schema.

	\item [@Contain] When a field is annotated with the \texttt{@Contain} annotation, then this field is considered as \textit{traversal}. 
	In general, traversals describe a minimum spanning tree that is called \textit{spine} and ensures reachability of values.
	The spine is used in implementations that need a depth-first search by distinguishing between the actual information and the cross-references of the spanning tree.
	If a spanning tree is defined, then all nodes in a model must be uniquely reachable by following just the spine fields \cite{storm2012object}.
	An example of such functionality is the equivalence between managed objects that is presented in Section \ref{Managed Object equivalence}.
	Sometimes traversal fields describe composition, or ``is a part of'', relationships \cite{loh2012managed}.

	\item [@Optional] When the \texttt{@Optional} annotation is on a field's definition this field can include \texttt{null} values.
	\texttt{Inverse} fields are \texttt{Optional}. 

	\item [Java Inheritance] In addition to the Java annotations, our language uses more Java mechanisms for schemas definition. 
	Java inheritance is one of them. 
	A \texttt{schemaKlass} can extend another Klass (super), which works as the traditional Java inheritance, supporting sub typing mechanisms.
	Implementing this we introduce a \textit{Type Hierarchy} model that includes super and sub classes on managed objects.
	Note that since we use interfaces for \texttt{schemaKlass}, we implicitly support multiple inheritance because a Java interface can extend more than one interfaces.

	\item [Java Collections] Finally, another Java mechanism that we use is the definition of a field that includes many values.
	To define such a field, a programmer has to declare a field's \texttt{Type} as a \texttt{java.util.List} or a \texttt{java.util.Set} of this \texttt{Type}.

\end{description}

Using all the aforementioned constructs of our data definition language, a programmer can define any kind of schema, even itself (see Section \ref{Self-Describing Schemas}).
Schema definition examples are presented in Chapter \ref{Example Application} Listings \ref{lst:Machine_Schema}, \ref{lst:State_Schema} and \ref{lst:Transition_Schema}.
In those definitions the above concepts can be recognized and their meaning can be revealed in context.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{IFactories}\label{IFactories}
However, even if we have the definitions of schemas, we still need a way to create instances of managed data described by them.
We can not use Java's mechanisms\footnote{\texttt{new} keyword} for this functionality since we need them to be managed data and not ordinary objects.
Thus, we use Java interfaces to define instance factories.
An \texttt{IFactory} is a list of \textit{constructor definitions} for specific schemas.

The methods in this interface are used similarly to the constructors in a Java class, while their implementation is handled by the data managers.
Since those methods are constructors, we can define a constructor with or without initial values.
Unfortunately, we have encountered a limitation regarding constructors with initialization values, making them inappropriate to use in complicated schemas.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Methods Ordering Issue}\label{Methods ordering}
The problem lays on Java's reflection mechanisms in terms of methods ordering.
More specifically, when the methods of a \texttt{java.lang.Class} are requested by using the \texttt{public Method[] getMethods()} method\footnote{
	As it is mentioned in \url{https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html\#getMethods--}, the elements in the returned array are not sorted and are not in any particular order.}, 
the returned values are not ordered the way as defined in the source code.
Consequently, since the schema definition is reflectively analyzed in the data managers and is dependent on that order, those methods can not be used in the initialization of values.

However, we overcame this difficulty and were able to support this feature in an alternative manner.
In our implementation both the defined methods and the fields are \textbf{alphabetically ordered} by name before being initialized.

That feature can be used by the programmer although it can be confusing.
Therefore, as an advice, we suggest to either provide constructors without initialization values or to write constructors with only \textbf{primitive} initialization values in \textbf{alphabetical order}.
Otherwise we risk getting values in a random order leading to an error or a wrong value assignment.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Data Managers Implementation}\label{Data Managers Implementation}
However, the schemas are not a complete managed data specification without a corresponding \texttt{Data Manager}.
A data manager is responsible for interpreting the schema and building virtual objects (managed objects). 
The managed object's fields are defined by the given schema and acts according to the specifications given by the data manager.
Additionally, the data manager ensures that the data given are valid with respect to the schema.
More specifically, the data managers describe how a schema definition is handled from the outside world and what its specifications are.
These properties may include \ac{ccc} that can be described separately by special data managers, separating schema and concern definitions.
Thus, a managed object can have multiple interpretations based on the data manager that is used to interpret it.

A data manager is initialized with a \texttt{Schema} and provides a new \texttt{Managed Object} instance whose properties are defined by that data manager.
Additional to the \texttt{Schema} that includes a Set of \texttt{Type}s (\texttt{Primitive}s or \texttt{Klass}es), it also needs a \texttt{IFactory} that declares the constructors of the given schema \texttt{Klass}.
The data manager through its \texttt{factory} method interprets the schemas and builds new \texttt{IFactories}, which in turn create \texttt{Managed Objects} with the specifications of the data manager.

In the example presented in listing \ref{lst:Basic data Manager Example}, Line \ref{line:basic_data_manager_definition} defines a basic data manager.
This data manager gets the \texttt{IFactory} and the \texttt{Schema} of a state machine as input in the \texttt{factory} method. 
Next, Line \ref{line:basic_data_manager_schema_factory_definition} shows a new \texttt{IFactory} instance is being created, which builds managed objects with the specifications attached from the basic data manager.
Finally, Line \ref{line:basic_data_manager_definition_instance} illustrates how the managed object instances with those specifications can be built.

\begin{sourcecode} [H]
	\begin{lstlisting}[language=Java, escapechar=|]
// Create a basic data manager for state machines
BasicDataManager basicDataManagerForStateMachines = new BasicDataManager(); |\label{line:basic_data_manager_definition}|

// Create a factory that makes managed objects 
// with the specifications of the basic data manager.
StateMachineFactory stateMachineFactory = basicDataManagerForStateMachines
		.factory(StateMachineFactory.class, stateMachineSchema); |\label{line:basic_data_manager_schema_factory_definition}|

// Build an instance of managed object with those specifications.
Machine stateMachineInstance = stateMachineFactory.Machine(); |\label{line:basic_data_manager_definition_instance}|
	\end{lstlisting}
	\caption{Basic data Manager Example}
	\label{lst:Basic data Manager Example}
\end{sourcecode}

\subsubsection{Basic Data Manager}
As described above, we use Java interfaces to define schema Klasses that include fields. 
Those fields are dynamically discovered by a schema loading process and provided to the data manager as schemas.
A data manager has the ability to determine the fields and methods of the managed object during runtime.
In addition, when the data manager adds functionality on a managed object then it first delegates the calls to its specifications and then to the fields of an instance.
In order to dynamically interpret a schema inside a data manager and delegate its functionalities, we used Dynamic Proxies.

In our implementation we have separated the Proxy factory (\texttt{DataManager}) from the Invocation Handler (\texttt{MObject}).
This way, the \texttt{DataManager} class is responsible for creating proxy instances of \texttt{IFactories}. 
The \texttt{IFactory} creates proxy instances with the \texttt{MObject} class instances as invocation handlers.
The \texttt{MObject} instances are responsible for interpreting the schema and delegating actions using their invocation handling implementation. 
Figure \ref{fig:DataManager_and_MObject} illustrates this structure.
As it can be seen the data manager is a \textit{factory} that has a single exposed method, \texttt{factory()}, that is used to build an \texttt{IFactory} instance, which in turn builds \texttt{MObject} instances.

\begin{figure}[H]
	\centering
  	\fbox{\includegraphics[width=.85\textwidth]{figures/DataManager_and_MObject.png}}
  	\caption{Data Manager and MObject}
  	\label{fig:DataManager_and_MObject}
\end{figure}

The two level \textit{proxing} process that the \texttt{DataManager} class performs, from the basic data manager to IFactory and then to MObject, can be seen in Listing \ref{lst:Basic Data Manager}.
Note that the \texttt{createManagedObject} is \texttt{protected} for the sub data managers to override it in order to create MObjects of preference.

\begin{sourcecode} [H]
	\begin{lstlisting}[language=Java, escapechar=|]
public <T extends IFactory> T factory(
	Class<T> factoryClass, Schema schema, Class<?>... proxyInterfaces) 
{
	// add the extra proxied interfaces
	for (Class<?> proxiedInterface : proxyInterfaces) {
		this.addProxiedInterface(proxiedInterface);
	}

	// add the klass interfaces of the schema
	for (Klass klass : schema.klasses()) {
		this.addProxiedInterface(klass.classOf());
	}

	return (T) Proxy.newProxyInstance(
		factoryClass.getClassLoader(),
		new Class<?>[]{factoryClass},
		(proxy, method, args) -> // invocation handler
			createProxiedManagedObject(factoryClass, schema, method, args) // mobject
		);
}

protected Object createProxiedManagedObject(...) {
	//...
	final MObject managedObject = createManagedObject(schemaKlass, inits);
	return Proxy.newProxyInstance(
		schemaFactoryCallingMethodClassLoader,
		proxiedInterfaces.toArray(new Class[proxiedInterfaces.size()]),
		managedObject
	);
}
\end{lstlisting}
	\caption{Basic Data Manager}
	\label{lst:Basic Data Manager}
\end{sourcecode}

\subsubsection{Stacking Data Managers}
In order to create a stack of data managers that combine behavior and specifications, we can use inheritance.
Figure \ref{fig:DataManager_and_MObject} shows how this works.
In detail, \texttt{AnotherDataManager} extends \texttt{BasicDataManager} and simply overrides the \texttt{createManagedObject} and the \texttt{factory} methods.
The \texttt{createManagedObject} method is responsible for creating a new instance of an \texttt{MObject}.
In this case, the \texttt{createManagedObject()} method will create a new \texttt{AnotherMObject} instance.
The \texttt{factory} method is responsible of creating a new \texttt{IFactory} instance.
Note that it is important that the data managers inherit from a base data manager, leading to the modular aspect of the data managers.
As it can be seen, for stacking data managers we used the \textit{Decorator Pattern} \cite{gamma1995design} which is mentioned also in Cook et al. \cite{loh2012managed} as a strategy for static \ac{oop} languages.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{MObjects}\label{sec:Managed Objects}
The \texttt{MObject}, is an implementation of the \texttt{InvocationHandler} interface.
Thus, the \texttt{MObject}'s \texttt{invoke()} method is called in every field access of the managed object's instance.
To manipulate its fields' values this object has two methods, \texttt{\_set()} and \texttt{\_get()}.
In the implementation of these methods additional checks are performed to ensure the correctness of types and structure of the values.
Therefore, a type checker in the schemaKlass level has been implemented in the particular place.
The setter and getter methods can be overridden from derived \texttt{MObject}s in order to \textit{Decorate} the basic \texttt{MObject} with their functionality. 
Of course they require to call their \texttt{supers} for running the type checker.

The \texttt{MObject} is the \textit{backing object} that stores a reference to the \texttt{schemaKlass} and its implementation represents an instance of that \texttt{schemaKlass}.
That \texttt{schemaKlass} is a meta class that describes the layout of the \texttt{MObject} and keeps the \texttt{Field}s and their \texttt{Types}.
During construction, the fields of the \texttt{MObject} are specified by its \texttt{schemaKlass}.
When a field check has to be performed, the \texttt{MObject} uses its \texttt{schemaKlass}.

Overall, one can easily argue that this class defines the main functionality of managed data.
In particular, this class is the \textit{interpreter} of managed data.
Therefore, it is responsible for handling the calls to methods (invocation handler), invoke default methods, setup and initialize field values, based on its \texttt{schemaKlass}, and internally perform the \textit{type checking}.
A detailed presentation of this class and its action is explanation in Appendix \ref{apdx:MObject}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Implementing a Data Manager}\label{Implementing a Data Manager}
The implementation and the integration of a new data manager is straight forward in our framework.
As it can be seen in Figure \ref{fig:DataManager_and_MObject}, the basic components of a new data manager implementation are the \texttt{Data Manager} class (proxy) and the \texttt{MObject} class (invocation handler).

First, to follow the modularity aspect and the ability to stack data managers together combining their specifications, we need to inherit from, at least, the \texttt{BasicDataManager} and its \texttt{MObject} respectively.
A simple data manager that could be useful is a data manager that introduces immutability to its managed objects.
A \texttt{Lockable} data manager should first inherit the \texttt{BasicDataManager} to get its field access specification.
The implementation of the \texttt{LockableDataManager} is illustrated in \ref{lst:Lockable Data Manager}.

\begin{sourcecode} [H]
	\begin{lstlisting}[language=Java, escapechar=|]
public class LockableDataManager extends BasicDataManager {

	@Override
    public <T extends IFactory> T factory(
    	Class<T> factoryClass, Schema schema, Class<?>... proxyInterfaces) {
        // Add the Lockable class in order to use it in the managed object.
        return super.factory(factoryClass, schema, Lockable.class);
    }

	@Override
	protected MObject createManagedObject(Klass klass, Object... _inits) {
		return new LockableMObject(klass, _inits);
	}
}
	\end{lstlisting}
	\caption{Lockable Data Manager}
	\label{lst:Lockable Data Manager}
\end{sourcecode}

Additionally, it should add some \textit{locking} mechanism to ensure immutability of its objects.
This is defined in the \texttt{Lockable} interface, which is responsible of ensuring the implementation of the specifications. 
Listing \ref{lst:Lockable Interface} shows the specifications of the interface.

\begin{sourcecode} [H]
	\begin{lstlisting}[language=Java, escapechar=|]
public interface Lockable {
	void lock();
}
	\end{lstlisting}
	\caption{Lockable Interface}
	\label{lst:Lockable Interface}
\end{sourcecode}

Since we have the specifications and the data manager that creates the \textit{Lockable} managed object, we still need the implementation.
The implementation is located in the \texttt{MObject} and in this case the \texttt{LockableMObject}, 
Listing \ref{lst:Lockable Managed Object}.

\begin{sourcecode} [H]
	\begin{lstlisting}[language=Java, escapechar=|]
public class LockableMObject extends MObject implements Lockable {
	private boolean isLocked = false;

	public LockableMObject(Klass schemaKlass, Object... initializers) {
		super(schemaKlass, initializers);
	}

	public void lock() {
		isLocked = true;
	}

	@Override
	public void _set(String name, Object value) 
	throws NoSuchFieldError, InvalidFieldValueException, NoKeyFieldException {
		if (isLocked)
	    	throw new IllegalAccessError(
	    		"Cannot change " + name + " of locked object " + schemaKlass.name() + ".");
		super._set(name, value);
	}
}
	\end{lstlisting}
	\caption{Lockable Managed Object}
	\label{lst:Lockable Managed Object}
\end{sourcecode}

The \texttt{LockableMObject}, by extending the \texttt{MObject} and implementing the \texttt{Lockable} interface, inherits the basic functionality of a managed object and gets a specification description respectively.
Its role is to implement the logic of the immutability, which is as simple as it looks.
In order to use this functionality, one needs to create managed objects using this data manager.
An example is shown in Listing \ref{lst:Immutability Example}.

\begin{sourcecode} [H]
	\begin{lstlisting}[language=Java, escapechar=|]
LockableDataManager lockableFactory = new LockableDataManager();
PointFactory lockablePointFactory = 
	lockableFactory.factory(PointFactory.class, pointSchema);
Point2D lockablePoint = lockablePointFactory.Point2D(1, 2);

// It was mutable until now, now it is locked (immutable).
((Lockable)lockablePoint).lock();
try {
	lockablePoint.x(2); // Should throw here since its immutable.
} catch (IllegalAccessError e) {
	System.err.println("IllegalAccessError: " + e.getMessage());
}
	\end{lstlisting}
	\caption{Immutability Example}
	\label{lst:Immutability Example}
\end{sourcecode}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Self-Describing Schemas}\label{Self-Describing Schemas}
As explained by Cook et al. \cite{loh2012managed}, a self-describing schema is a schema that can be used to define schemas, including itself.
Our framework is fully self-described, the schemas are also described by schemas which are both models \cite{kurtev2006model}. 
To allow schemas to be managed data we need a ``self-describing schema mechanism'' or \textit{SchemaSchema}.
Through the \textit{SchemaSchema} the approach of managed data can be applied at the meta level as well.

The reason that a self-describing schema is important is because schema schemas can be used from factories (IFactory) to create schemas.
The schema of schemas is just a schema that allows the creation of schemas, including its own schema \cite{storm2012object}.
Additionally, by presenting the schema as the first-class model\cite{kurtev2006model}, they can be extended in the same way just like ordinary models.

\subsection{SchemaSchema}\label{sec:SchemaSchema}
By using Java interfaces the \textit{Schema} classes are tightly coupled structurally to the Java interfaces used to define them.
Since we want to decouple from Java interfaces and reflection we need our own \textit{Klass system}.
In order to be self-describing we want this Klass system to be also represented as managed data. 
To model the structure of a \texttt{Schema} itself we need to be able to describe a class as a collection of \texttt{Fields}, each of which has a \texttt{name} and a \texttt{Type} \cite{loh2012managed}. 
Thus, for our \textit{SchemaSchema} definition we need a \texttt{Type}, a \texttt{Field} and a \texttt{Schema} as a collection of \texttt{Type}s. 
A \texttt{Type} could be both a \texttt{Primitive}, without \texttt{Fields}, and a \texttt{Klass}, with a set of \texttt{Fields}.
Additionally, those \texttt{Fields} may have some extra meta data attributes that are explained in Section \ref{Schema Definition}.

A schema like this can describe itself since every concept used in the explanation is de facto included in the definition.
For a self-describing implementation we need to describe our own SchemaSchema. 

Figure \ref{fig:SchemaSchema_definition} illustrates the modeling of this definition.

\begin{figure}[H]
	\centering
  	\fbox{\includegraphics[width=.85\textwidth]{figures/SchemaSchema_definition.png}}
  	\caption{The schema of schemas}
  	\label{fig:SchemaSchema_definition}
\end{figure}

\subsection{SchemaFactory}\label{sec:SchemaFactory}
Considering that we have the schema of our schema (\textit{SchemaSchema}) we need a way to create instances of those \textit{schemaSchemaKlasses}.
In this case, as we do with the normal schemas, we use an IFactory definition.
However, this time it is a \textit{SchemaFactory} that defines constructors of all the schema klasses that are needed to describe our \textit{SchemaSchema}.
Listing \ref{lst:SchemaFactory} shows its definition.

\begin{sourcecode} [H]
	\begin{lstlisting}[language=Java, escapechar=|]
public interface SchemaFactory extends IFactory {
    Schema Schema();
    Primitive Primitive();
    Klass Klass();
    Field Field();
    Field Field(
    	Boolean contain, Boolean key, Boolean many, String name, Boolean optional);
}
	\end{lstlisting}
	\caption{SchemaFactory}
	\label{lst:SchemaFactory}
\end{sourcecode}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Schema Loading}\label{sec:Schema Loading}
To construct the Klass system we need to analyze the Java interfaces using reflection and then build actual instances of the Schema, Klass, Field etc. using the appropriate factory.
The \texttt{SchemaLoader} is responsible of this process.

\texttt{SchemaLoader}'s \texttt{load} static method takes as input a Set of interfaces, which are the schema definitions, a \texttt{SchemaFactory} that includes constructor definitions of the \texttt{SchemaSchema} and returns a new instance of \texttt{Schema}.
During the reflective analysis of the input interfaces the \texttt{SchemaLoader} builds the corresponding \texttt{Types} and \texttt{Fields} of those interfaces using the \texttt{SchemaFactory}.
A \texttt{Schema} consists of the Set of these \texttt{Types}.
An example taken from Chapter \ref{Example Application}, is shown in Listing \ref{lst:SchemaLoader Example}.

\begin{sourcecode} [H]
	\begin{lstlisting}[language=Java, escapechar=|]
Schema schemaSchema = ...;
SchemaFactory sf = basicFactory.factory(SchemaFactory.class, schemaSchema);

Schema stateMachineSchema = SchemaLoader.load(
	sf, Machine.class, State.class, Transition.class);
	\end{lstlisting}
	\caption{SchemaLoader Example}
	\label{lst:SchemaLoader Example}
\end{sourcecode}

In its implementation, the \texttt{SchemaLoader} gets as input a \texttt{SchemaFactory} and a set of interfaces that describe the state machine schema.
Next, it returns a new instance of the state machine Schema.
This schema consists of a set of schema Klasses that are described by interfaces, namely \texttt{Machine.class}, \texttt{State.class} and \texttt{Transition.class}.
Next, the \texttt{SchemaLoader} analyzes the definition of those schemas using reflection and then makes a \texttt{Schema} by using the \texttt{SchemaFactory} that it has been given.
A more detailed description of this process is given in Appendix \ref{appdx:SchemaLoading}.
% #important
In general \texttt{SchemaLoader} can be seen as our parser, which accepts a description of language (the interfaces) and a method create objects of its components (the schema factory).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Bootstrapping}\label{sec:Bootstrapping}
Considering that SchemaSchema is managed data itself, we can use the SchemaLoader to build a new SchemaSchema.
Nonetheless, we need a description of that SchemaSchema, which will be used during the loading process to build the schema Klasses.
As a result, we need a \textit{Bootstrap Schema} to jumpstart this process.
The \textit{Bootstrap Schema} is exclusively self-describing, as it must manage itself \cite{loh2012managed}, and hardcoded in its own class, \texttt{BootSchema}.

\subsection{Cutting the umbilical cord}\label{subsec:Cutting the umbilical cord}
Having a \texttt{BootSchema} in place we can now create ``real'' \texttt{SchemaSchema}s \footnote{
	We call them real because they are managed data and not hard-coded.}.
For consistency, we use those ``real'' \texttt{SchemaSchema}s in order to build other schemas, this way everything is managed data.
After building a real SchemaSchema we no longer need the \texttt{BootSchema}, which leads to a process that we call ``Cutting the umbilical cord''.
An example of ``Cutting the umbilical cord'' is shown in Listing \ref{subsec:Cutting the umbilical cord}, where we use the \texttt{BootSchema} to build the \texttt{realSchemaSchema} and then we use this \texttt{realSchemaSchema} to build another \texttt{realSchemaSchema} (\texttt{realSchemaSchema2}).

\begin{sourcecode} [H]
	\begin{lstlisting}[language=Java, escapechar=|]
final BasicDataManager basicFactory = new BasicDataManager();
final SchemaFactory schemaFactory = 
	basicFactory.factory(SchemaFactory.class, new BootSchema());
final Schema realSchemaSchema = SchemaLoader.load(
        	schemaFactory,
         	Schema.class, Type.class, Primitive.class, Klass.class, Field.class,
        	Primitives.class); |\label{line:Primitives}|

final BasicDataManager basicFactory2 = new BasicDataManager();
final SchemaFactory schemaFactory2 = 
	basicFactory2.factory(SchemaFactory.class, realSchemaSchema);
final Schema realSchemaSchema2 = SchemaLoader.load(
        	schemaFactory2, 
        	Schema.class, Type.class,  Primitive.class, Klass.class, Field.class);
	\end{lstlisting}
	\caption{Cutting the umbilical cord}
	\label{lst:Cutting the umbilical cord}
\end{sourcecode}

Figure \ref{fig:schema_schema_models} illustrates the models during a bootstrapping process.
As it can be seen, the \texttt{BootSchema} is used in order to describe the Schema Schema, making the Schema Schema independent and managed data itself.
Thus, it can be used to create other schemas like the Machine schema or even itself.

\begin{figure}[H]
	\centering
  	\fbox{\includegraphics[width=.4\textwidth]{figures/schema_schema_models.png}}
  	\caption{Boot Schema models}
  	\label{fig:schema_schema_models}
\end{figure}

\subsection{Primitives Definition}\label{Primitives Definition}
Since the Bootstrap Schema defines the primitive types for its description, the real schema schema needs a way to include them as well.
These initial Java primitives supported in our implementation are shown in Table \ref{tbl:primivites_table}.

\begin{table}[H]
	\centering
	\begin{tabular}{@{}lccc@{}}
	\toprule
	                 & \textbf{Class} & \textbf{Name} & \textbf{Default Value} \\ \midrule
	\textbf{Integer} & Integer.class  & ``Integer''   & 0                      \\
	\textbf{int}     & int.class      & ``int''       & 0                      \\
	\textbf{Boolean} & Boolean.class  & ``Boolean''   & false                  \\
	\textbf{boolean} & boolean.class  & ``boolean''   & false                  \\
	\textbf{String}  & String.class   & ``String''    & ``''                   \\
	\textbf{Double}  & Double.class   & ``Double''    & 0.                     \\
	\textbf{Float}   & Float.class    & ``Float''     & 0.f                    \\
	\textbf{Class}   & Class.class    & ``Class''     & null                   \\
	\textbf{Object}  & Object.class   & ``Object''    & null                   \\ \bottomrule
	\end{tabular}
	\caption{Primitives Table}
	\label{tbl:primivites_table}
\end{table}

To define those primitives we use an interface called \textit{Primitives}, introduced during the loading of the real schema, as seen in Line \ref{line:Primitives} of Listing \ref{lst:Cutting the umbilical cord}.
The definition of this interface is shown in Listing \ref{Primitives Definition} which is a simple \texttt{Class/Name} mapping \footnote{We use the ``\_'' prefix convention in order to define names of primitives that are reserved words in Java.}. 

\begin{sourcecode} [H]
	\begin{lstlisting}[language=Java, escapechar=|]
public interface Primitives {
	Integer Integer();
	int _int();
	Boolean Boolean();
	boolean _boolean();
	String String();
	Class Class();
	Float Float();
	Double Double();
}
	\end{lstlisting}
	\caption{Primitives Definition}
	\label{lst:Primitives Definition}
\end{sourcecode}

The benefits of such a definition is that the \texttt{Primitives} interface is extensible.
By extending it one can add more primitives in the schema as long as it is introduced during the schema loading.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation Issues}\label{Implementation Issues}
The fact that we use Java reflection and dynamic proxies, along with the fact that everything is managed data, even the schemaSchema, introduces some issues, including the methods ordering problem described in Section \ref{Methods ordering}.

\subsection{Equivalence}\label{Managed Object equivalence}
The \texttt{bootstrapSchema}, \texttt{realSchemaSchema} and \texttt{realSchemaSchema2} managed objects from the Listing \ref{subsec:Cutting the umbilical cord} should be equal because they ultimately describe the same \textit{Schema}.

However, since, apart from the \texttt{bootstrapSchema}, they are managed data and not normal Java objects, we need a way to check for equality on managed objects.
We have implemented the equivalence functionality for managed objects, using the \textit{Equality Checking for Trees and Graphs
algorithm} by Michael D. Adams and R. Kent Dybvig \cite{adams2008efficient}.

\subsection{The classOf field}\label{The classOf field}
As it has be presented in Section \ref{Dynamic Proxies}, for a proxy object to conform with interfaces and be casted to any of them, it needs these interfaces during its initialization.
To support that, we have added the \texttt{classOf} field in the \texttt{Type} schema Klass, which is of type \texttt{java.lang.Class} and is a reference of the Java class that this schema Klass is described to.

\subsection{Hash-code of Managed Objects}\label{Hashcode of Managed Objects}
To avoid any unpredictable activities that a \texttt{hashCode} invocation would bring in managed objects, we have omitted it. 
We do not depend on the ordinary \texttt{hashCode} for managed objects, we do not call it and therefore we have not implemented it.
If it is a collection field type, then the field has to have a \texttt{Key} field. 
In this case, we obtain the value of the key field and index it into a \texttt{HashMap}. 

Using the \texttt{Key} field as the key of the hashmap works whether it is a primitive or not since we get the \texttt{Object.hashCode()} of that key.
However, that suggests that the key is not of our schema Klass system but a Java type.
Finally, the \texttt{MObject} invocation handler delegates the call of the \texttt{hashCode} method to the real object so that it would never fail, although this is not suggested because it may lead to unpredictable results.

\subsection{Java 8 Default Methods}\label{Java 8 Default Methods}
Java 8 supports the definition of default methods in interfaces.
According to the specification\footnote{\url{https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html}}, default methods enable the programmer to add new functionalities to the interfaces and can be used as method implementation in abstract classes.
We use Java 8 default methods in order to add functionality to our schema definitions. 
In particular, methods that are defined as \textit{default} are ignored during the interpretation and no fields are created for them.
We consider this as a helpful mechanism for defining functionality inside the schemas.
A notable feature is that the default method invocation in the MObject is \texttt{protected}, which makes it possible for the derived data managers to ``monitor'' when a default method is invoked.

\section{Benefits and Limitations}\label{Benefits and Limitations}
One of the advantages of this language is the simplicity of its usage. 
A programmer simply needs to define the schemas, followed by the data managers, and can easily write a program using them.
The language takes care of the dependencies, references and any other underline mechanisms.
Moreover, it uses Java concepts, which makes it safer in terms of type checking and definitions making it easier for Java developers to adapt.
Furthermore, by being a self-describing language it is no longer bounded to the Java constructs transforming everything into managed data.
Finally, the effortless mechanism of stacking data managers makes it significantly modular on every level, meta or not.

However, in addition to the implementation issues described in the previous section, there are significant performance implications since we use Java reflection and dynamic proxies to dynamically interpret the schemas. 
This makes it unfavorable for applications that focus on performance and are based on \ac{jvm} optimizations.

Another issue that arises is that integration in existing systems is complicated considering every model has to be redefined as a schema and every functionality has to be reimplemented in data managers.
However, an existing system integration is presented in Chapter \ref{AspectRefactoring}.

% \section{Claims}\label{Implementation Claims}
% We claim that managed data leads to a powerful data abstraction that gives the programmer control over fundamental mechanisms of data creation and manipulation \cite{loh2012managed}.
% Those mechanisms are traditionally predefined by the programming languages. 
% Managed data gives control over them by using data managers.
% Moreover, we claim that managed data introduces a modular way to define data and aspects of data. 
% In Chapter \ref{AspectRefactoring} we present how to \textit{aspect refactor} an existing application using managed data.
